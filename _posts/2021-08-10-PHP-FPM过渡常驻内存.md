PHP-FPM过渡常驻内存
使用php开发的程序员大多数开发的都是web或者api接口，要么就是调用java的后端服务实现对外公开接口服务，这些开发大多数采用nginx+php-fpm模式来开发。
大多数的php开发者都没有常驻内存的概念，毕竟都是大多数都是基于fpm模式来进行开发，很多工作fpm都帮我们做好管理好了，php的开发者只需要管好自己的业务逻辑代码就已经足够了。
常驻内存和php-fpm模式有什么区别？

 |  注意   | 常驻内存  | php-fpm |
 |  ----  | ----  | ---- |
 | 变量  | 不释放 | 自动释放 |
 | 对象  | 只new一次 | 每次请求都需要重新new |
 | 单例  |在初始化阶段把对象存到内存|每个请求重建创建和销毁对象|  
		
		
		
单例	在初始化阶段把对象存到内存	每个请求重建创建和销毁对象
### 在使用常驻内存框架需要注意什么？

- 内存释放
- 数据污染
- 资源释放
- 静态变量保存的对象不会被释放，需要手动管理
- 禁止使用exit和die
- 禁止使用sleep时间长的函数，防止导致Worker进程退出
- 不同Worker进程创建的对象和连接是不能互通的，创建连接池需要注意
- 定义公共函数的时候要使用 function_exists 判断函数是否存在，否则会提示重名
- 类引入文件需要使用 include_once 或者 require_once 否则会提示类名重复
- 修改代码需要重启服务才能生效
- echo、print_r、var_dump不会输出到浏览器
- 不能像fpm一样使用$_GET、$_POST、$_REQUEST、$_SESSION、$_COOKIE、$_SERVER等$_开头的变量。
### 数据污染问题演示
```angular2html
<?php
Swoole\Runtime::enableCoroutine(true);
$_array = [];
$http = new swoole_http_server("127.0.0.1", 9501);
$http->set(['worker_num'=>1]);
$http->on("start", function ($server) {
});
$http->on("request", function ($request, $response) {
    global $_array;
    if ($request->server['request_uri'] == '/a') {
        echo "---------------a请求开始----------------\n";
        print_r($_array);
        echo "---------------a请求开始----------------\n";

        $_array['key'] = 'My Name is php';

        co::sleep(1);

        echo "---------------a请求修改----------------\n";
        print_r($_array);
        echo "---------------a请求修改----------------\n";

        $response->end($_array['key']);
    } else {
        echo "---------------其他请求开始----------------\n";
        print_r($_array);
        echo "---------------其他请求开始----------------\n";

        $_array['key'] = 'My name is Sunny';

        echo "---------------其他请求修改----------------\n";
        print_r($_array);
        echo "---------------其他请求修改----------------\n";

        $response->end();
    }

});
$http->start();
```
